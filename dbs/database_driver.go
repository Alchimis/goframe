package dbs

import (
	internal "inter"
	"log"
)

/*
мозговой штурм. что представлет из себя база данных - кучу записей над которыми можно производить определённые операции
некоторые из этих операций: поиск, сортировка, вставка, удаление
эти операции выполняються некоторой системой. система может принимать на вход некий язык для управления
весь функционал базы данных может быть выполнен в языке
следавательно базой являеться формирование языка и его применение

это всё конечно прикольно но меня интересует конкретно мой язык, который я могу подать на вход любой базе данных, для которой я напишу адаптер по мой язык
проще говоря мне нужет конкретный менее абстрактный фунционал, который можно натянуть на любую бзу данных

например я хочу найти пользователя по имени и тд, или канал по имени и тд

заключение: тут я могу делать что захочу в рамках логики своего языка, через интерфейсы будет перелаваться адаптироания логика юазы данных
*/

type Database interface {
	Run() (*Database, error)
}

var DatabaseIMPL *Database

func HandleError(err error) {
	log.Println(err)
}

func Drive(db Database) {
	var err error
	DatabaseIMPL, err = db.Run()
	if err != nil {
		HandleError(err)
	}
}

type UserQuery interface {
	GetAllUsers() []internal.User
	GetUsersWhere(internal.Condition) []internal.User
	DeleteUsersWhere(internal.Condition) []internal.User
	// тут я хз, надо передавать наверно что то более связанное с пользователем. Однако ж создать полностью пустые поля нельзя, у базовых типов значения будут нулевые, так что тут хз возможно как то отобразить в типах смогу, но думаю это будет просто ебланством
	// ок просто придумать проверку на нулевые поля
	UpdateUsersWhere(internal.Condition, internal.User) []internal.User
	// вообще передавать для создания пользователя в качестве пропсов условия а не самого пользователя как будто бы тупая идея
	// с ником и паролем понятно, что делать с конектами
	// конекты могут быть нилом так что если пустая залупа то удаляем всё к хуям, если нил то не трогаем
	// если дело дойдёт до каких то примитивов, нулевое значение которых можно толковать двояко, то придётся выкручиваться нахуй с типами. а ещё лучше засунуть всё в опшенал
	CreateUser(internal.User) internal.User
}

/*func GetUser(db *UserQuery, condition internal.Condition) internal.User {

	return (*db).GetUsersWhere(condition)
}*/
